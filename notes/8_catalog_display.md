# 8: Catalog Display
- We have the products controller, which gives teh seller the ability to work with the products
- Need to create a second controller, the Store, which interacts with the paying customers

# Generate the controller
- rails g controller Store index
- add a route `root 'store#index', as: 'store_index'`
  - also make the root route
- edit the `index` action to get all products ordered by title `Product.order(:title)

# Write the view
- Create a view, include the notice code, then just an unordered list of products

# Adding a page layout
- Want to create a decent looking banner and a sidebar on public-facing pages

## stylesheet_link_tag()
- Generates a `<link>` tag to our application's stylesheet and specifies an option to enable TurboLinks

## javascript_pack_tag()
- Generates a `<script>` to load our application's scripts

## csrf_meta_tags
- Sets up all the behind-the-scenes data needed to prevent cross-site request forgery attacks, which will be important when we add forms

## @page_title
- By default, this is blank, but allows us to override in any controller where we want to set this

## yield
- Causes Rails to substitute in the page-specific content (stuff generated by the view invoked by the request)

# Rename application.css to application.scss
- Creates the manifiest file that will automatically include all style sheets available in the directory and any subdirectory
  - This is accomplished via the `require_tree` directive

## Sass vs CSS
- Alows us to write more manageable rules:
```css
/* Sass */
.content {
  nav {
    ul {
      list-style: none;
    }
  }
}
```
vs
```css
/* CSS */
.content nav ul {
  list-style: none;
}
```
- Also allows us to use media queries, which we use to account for differences we'd like to see between mobile devices and computers
- Try to designed stylesheets using mobile first method
  - Defaults are designed to look great on mobile, additional rules written for computers

# Caching of Partial Results
- The store#index will be a highly-trafficked page
- To respond to requests for this page, we'd need to fetch every product from the database and render each one, but we can do better than that
- Since the catalog doesn't change that often, there is no need to start from scratch on each request

## Steps to create cache
- First, modify the dev config env to turn on caching
`rails dev:cache`
- Next, figure out your plan: we only need to rerender if a product changed, and even then we only need to render only the products that actually changed
  - So, we need to make two small changes to our template
  - First: mark sections of our template that we need to update if any product changes (@products)
  - Second, inside that section, mark the subsection that we need to update in order to update any specific product that changed (the product)
    ```ruby
    <ul class='catalog'>
      <% cache @products do %>
        <% @products.each do |product| %>
          <% cache product do %>
            <li>
              <%= image_tag(product.image_url) %>
              <h2><%= product.title %></h2>
              <p>
                <%= sanitize(product.description) %>
              </p>
              <div class='price'>
                <%= number_to_currency(product.price) %>
              </div>
            </li>
          <% end %>
        <% end %>
      <% end %>
    </ul>
    ```
    - In addition to bracketing the sections, we've also identified the data to associate with each: the complete list of products, and each individual product we're rendering